/*
*  LibreSignage UI controller functionality for simplifying tasks
*  such as input event handling.
*/

var $ = require('jquery');
var assert = require('ls-assert').assert;

exports.UIController = class UIController {
	constructor(elems) {
		this.event_running = false;
		this.elems = elems;

		for (let e of Object.values(elems)) {
			e.init(this);
		}
	}

	all(func, data, type) {
		/*
		*  Execute 'func' on all the UIElem instances of this
		*  UIController.
		*  - 'func' is the function to execute. Note that 'func'
		*    is added to the UIElem instance prior to executing
		*    it, meaning that 'this' in 'func' refers to the
		*    UIElem instance.
		*  - 'data' is passed as the first argument to 'func'.
		*  - 'type' can be used to filter the elements to execute
		*    the function on. 'type' should be a string corresponding
		*    to one of the type values of classes extending UIElem.
		*/
		var ret = true;
		for (let k of Object.keys(this.elems)) {
			if (type == null || this.elems[k].type == type) {
				this.elems[k]._tmp = func;
				ret = this.elems[k]._tmp(data);
				this.elems[k]._tmp = null;
				if (ret == false) { break; }
			}
		}
	}

	event_set_fired()    { this.event_running = true;  }
	event_set_finished() { this.event_running = false; }
	is_event_running()   { return this.event_running;  }

	add(name, elem) { this.elems[name] = elem; }
	rm(name) { delete this.elems[name]; }
	rm_all() { this.elems = {}; }
	get(name) { return this.elems[name]; }
}

exports.UIElem = class UIElem {
	/*
	*  Main UI element interface class.
	*
	*  Constructor arguments:
	*    - elem    = The element to attach to.
	*    - cond    = The condition checking function. This should
	*                return true if the input should be enabled and
	*                false otherwise. This is used by UIElem.state().
	*    - enabler = The enabler function. This function is called with
	*                true as the first argument when enabling the
	*                element and with false when disabling it.
	*    - attach  = A dictionary of event listeners. The keys are
	*                the event names and the values are the handlers.
	*    - defer   = If this function returns true when an event is
	*                is being handled, the event is deferred. Otherwise
	*                the callback function is executed.
	*/
	constructor(args) {
		assert('elem' in args);
		assert('cond' in args);
		assert('enabler' in args);
		assert('attach' in args);
		assert('defer' in args);

		this.type           = null;
		this.elem           = args.elem;
		this.cond           = args.cond;
		this.attach         = args.attach;
		this.defer          = args.defer;

		if (args.enabler) {
			this.enabler = args.enabler;
		} else {
			// Set a default enabler function.
			this.enabler = function(elem, state) {
				elem.prop('disabled', !state);
			}
		}

		/*
		*  Attach event listeners to 'elem'. Note that concurrent
		*  events in the same UIController fired by the user are
		*  always deferred.
		*/
		for (let key in this.attach) {
			this.get_elem().on(key, (...args) => {
				let ret = null;
				if (
					(args[0].originalEvent && this.is_event_running())
					|| (this.defer && this.defer())
				) {
					console.log(`UIElem: '${key}' deferred.`);
				} else {
					this.event_set_fired();
					ret = this.attach[key].apply(null, args);
					if (ret instanceof Promise) {
						ret.then(
							() => { this.event_set_finished(); }
						).catch(
							(e) => { throw e; }
						);
					} else {
						this.event_set_finished();
					}
				}
			});
		}
	}

	init(controller) {
		this.event_set_fired    = controller.event_set_fired;
		this.event_set_finished = controller.event_set_finished;
		this.is_event_running   = controller.is_event_running;
	}

	event_set_fired() {}
	event_set_finished() {}
	event_is_event_running() {}

	get_elem() {
		if (typeof this.elem == 'function') {
			return this.elem();
		} else {
			return this.elem;
		}
	}

	enabled(state) {
		// Manually set the enabled/disabled state.
		this.enabler(this.get_elem(), state);
	}

	state(cond_data) {
		/*
		*  Set the enabled/disabled state based on the
		*  return value of 'this.cond()'.
		*/
		if (this.cond) {
			this.enabler(this.get_elem(), this.cond(cond_data));
		}
	}
}

exports.UIInput = class UIInput extends exports.UIElem {
	/*
	*  UIElem class for DOM inputs.
	*/
	constructor(args) {
		assert('mod' in args);
		assert('getter' in args);
		assert('setter' in args);
		assert('clearer' in args);

		super(args);
		this.type = "input";

		this.mod     = args.mod;     // Modification checking callback.
		this.getter  = args.getter;  // Value getter.
		this.setter  = args.setter;  // Value setter.
		this.clearer = args.clearer; // Input clearing function.
	}

	get() {
		// Get the value of the input.
		if (this.getter) {
			return this.getter(this.get_elem());
		} else {
			return null;
		}
	}

	set(data) {
		// Set the value of the input.
		if (this.setter) {
			this.setter(this.get_elem(), data);
		}
	}

	is_mod(data) {
		// Check whether the input is modified.
		if (this.mod) {
			return this.mod(this.get_elem(), data);
		} else {
			return false;
		}
	}

	clear() {
		// Clear the input.
		if (this.clearer) {
			this.clearer(this.get_elem());
		}
	}
}

exports.UIButton = class UIButton extends exports.UIElem {
	/*
	*  UIElem class for DOM buttons.
	*/
	constructor(args) {
		super(args);
		this.type = "button";
	}
}

exports.UIStatic = class UIStatic extends exports.UIElem {
	/*
	*  UIStatic class for static DOM elements.
	*/
	constructor(args) {
		assert('getter' in args);
		assert('setter' in args);

		super(args);
		this.type = "static";

		this.getter = args.getter;
		if (!this.getter) {
			this.getter = function(elem) { return elem.html(); }
		}
		this.setter = args.setter;
		if (!this.setter) {
			this.setter = function(elem, html) { elem.html(html); }
		}
	}

	get() {
		/*
		*  Get the content of this UIStatic element.
		*/
		return this.getter(this.get_elem());
	}

	set(data) {
		/*
		*  Set the content of this UIStatic element.
		*/
		this.setter(this.get_elem(), data);
	}
}
