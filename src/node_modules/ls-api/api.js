var cookie = require('ls-cookie');
var APIError = require('./error.js').APIError;
var APIEndpoints = require('./endpoints').APIEndpoints;
var APISession = require('./session.js').APISession;
var assert = require('ls-assert').assert;

class APIInterface {
	constructor(host) {
		/*
		*  Create a new APIInterface object.
		*
		*  'host' is the hostname to use when calling API endpoints.
		*  The hostname is only required when using this library in
		*  a non-browser context, ie. in node.js. In that case you'll
		*  also need to install the 'xmlhttprequest' node.js module
		*  included in the LibreSignage devDependencies.
		*
		*  Remember to call APIInterface.init() after constructing
		*  the object.
		*/
		this.host = host;
		this.session = null;
		this.version = null;
		this.limits = null;

		// Load the XMLHttpRequest module for standalone use.
		if (typeof XMLHttpRequest === 'undefined') {
			assert(
				this.host != null && this.host != '',
				'Hostname required when using ls-api as a standalone library.'
			);
			try {
				global.XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
			} catch (e) {
				throw new Error(
					'XMLHttpRequest node.js module required when using ' +
					'ls-api as a standalone library.'
				);
			}
		}
	}

	async call(endpoint, data) {
		/*
		*  Call an API endpoint.
		*    * endpoint = One of the API endpoints defined in
		*                 the endpoints.js file.
		*    * data     = The data to send to the endpoint.
		*/
		return new Promise((resolve, reject) => {
			let req = new XMLHttpRequest();
			let conf = {
				'ctype': null,
				'data': null,
				'url': `${this.host ? this.host + '/' : ''}`
						+ `${endpoint.uri}`
			};

			req.addEventListener("load", function() {
				let tmp = null;
				switch(this.getResponseHeader('Content-Type')) {
					case 'application/json':
						tmp = JSON.parse(this.responseText);
						if (tmp.error) {
							reject(new APIError(tmp));
						} else {
							resolve(tmp);
						}
						break;
					default:
						resolve(this.responseText);
						break;
				}
			});
			req.addEventListener("error", function() {
				reject(new APIError({
					error: APIError.err('API_E_CLIENT'),
					e_msg: this.statusText
				}));
			});
			req.addEventListener("aborted", function() {
				reject(new Error({
					error: APIError.err('API_E_CLIENT'),
					e_msg: 'Canceled by user.'
				}));
			});

			if (endpoint.method === 'POST') {
				conf.ctype = endpoint.req_mime;
				switch(endpoint.req_mime) {
					case 'application/json':
						conf.data = JSON.stringify(data);
						break;
					case 'application/x-www-form-urlencoded':
						conf.data = data;
					case 'multipart/form-data':
						conf.ctype = null; // Let the browser decide.
						conf.data = data;
						break;
					default:
						reject(new APIError({
							error: APIError.err('API_E_CLIENT'),
							e_msg: `Invalid endpoint MIME ${endpoint.req_mime}`
						}));
						break;
				}
			} else if (endpoint.method === 'GET') {
				conf.url += `?${APIInterface.querify(data)}`
			} else {
				reject(new APIError({
					error: APIError.err('API_E_CLIENT'),
					e_msg: `Invalid endpoint method ${endpoint.method}.`
				}));
			}

			req.open(endpoint.method, conf.url);

			if (conf.ctype !== null) {
				req.setRequestHeader('Content-Type', conf.ctype);
			}

			if (endpoint.auth) {
				if (this.session === null) {
					reject(new APIError({
						error: APIError.err('API_E_NOT_AUTHORIZED'),
						e_msg: 'Not authenticated.'
					}));
				}
				req.setRequestHeader(
					'Auth-Token',
					this.session.get_token()
				);
			}
			req.send(conf.data);
		});
	}

	static querify(v) {
		/*
		*  Convert the dictionary 'v' into a URL query string.
		*  If 'v' === null, an empty string is returned.
		*/
		if (v === null) { return ''; }
		return Object.keys(v).map(
			(k) => {
				return encodeURIComponent(k) + '=' +
				encodeURIComponent(v[k]);
			}
		).join('&');
	}

	async login(user, pass, permanent) {
		this.session = new APISession(this);
		try {
			await this.session.login(user, pass, permanent);
		} catch (e) {
			this.session = null;
			throw e;
		}
	}

	async logout() {
		await this.session.logout();
		this.session = null;
	}

	async init() {
		/*
		*  Initialize the API object. You must call this function
		*  after constructing the object and before calling any
		*  other APIInterface function.
		*/
		let resp = null;
		let token = null;

		await APIError.init(this);

		resp = await this.call(APIEndpoints.SERVER_LIMITS, null);
		this.limits = resp.limits;

		resp = await this.call(APIEndpoints.VER_INFO, null);
		this.version = {
			ls: resp.ls,
			api: resp.api
		};

		// Attempt to reload web sessions.
		if (
			!this.is_standalone()
			&& (token = cookie.get_cookie('session_token')) != null
		) {
			this.session = new APISession(this);
			try {
				resp = await this.session.reload(token);
			} catch (e) {
				cookie.rm_cookie({'session_token': '', path: '/'});
				this.session = null;
				return;
			}
			if (resp === false) { this.session = null; }
		}
	}

	get_session()   { return this.session;   }
	get_ver()       { return this.version;       }
	is_standalone() { return typeof document === 'undefined'; }
}
exports.APIInterface = APIInterface;
